Operating System Project: Questions & Answers
============================================

1. Q: What is the purpose of the boot sector code?
A: The boot sector code initializes the system in 16-bit real mode, prints startup messages, loads the kernel from disk into memory, and switches the CPU to 32-bit protected mode before transferring control to the kernel.

2. Q: How does the system switch from real mode to protected mode?
A: The system loads the Global Descriptor Table (GDT), sets the appropriate bit in the CR0 register, and performs a far jump to a 32-bit code segment, as implemented in `switch_pm.asm`.

3. Q: What is the GDT and how is it set up?
A: The Global Descriptor Table (GDT) defines memory segments for code and data in protected mode. It is set up in `gdt.asm` and loaded by the bootloader before switching to protected mode.

4. Q: What is the role of the IDT?
A: The Interrupt Descriptor Table (IDT) maps interrupt vectors to their handler functions, allowing the CPU to handle exceptions and hardware interrupts. It is set up in `idt.c` and `idt.h`.

5. Q: How are interrupts handled in this OS?
A: Interrupts are handled by setting up the IDT with pointers to assembly stubs, which save CPU state and call C handler functions defined in `isr.c` and `interrupt.asm`.

6. Q: What is the difference between ISRs and IRQs?
A: ISRs (Interrupt Service Routines) handle CPU exceptions, while IRQs (Interrupt Requests) handle hardware interrupts. Both are set up in the IDT but have different handler functions.

7. Q: How does the OS remap the PIC?
A: The OS sends specific commands to the Programmable Interrupt Controller (PIC) to remap hardware IRQs to avoid conflicts with CPU exceptions, as seen in `isr.c`.

8. Q: How does the kernel handle user input?
A: The kernel receives input from the keyboard driver, processes commands like END and PAGE, and prints responses using the screen driver.

9. Q: How does the screen driver print characters to the screen?
A: The screen driver writes characters and attributes directly to the VGA text buffer at memory address 0xb8000.

10. Q: How is memory allocated in the kernel?
A: The kernel uses a simple bump allocator (`kmalloc`) that returns a pointer to free memory and increments the pointer for future allocations.

11. Q: What is the function of the timer driver?
A: The timer driver sets up the Programmable Interval Timer (PIT) to generate periodic interrupts, allowing the OS to track time and perform regular tasks.

12. Q: How does the keyboard driver work?
A: The keyboard driver registers an interrupt handler for keyboard IRQs, reads scancodes from the keyboard port, translates them to ASCII, and buffers the input.

13. Q: What is the structure of the Makefile and how does it build the OS?
A: The Makefile compiles C and assembly files, links them into a kernel binary, assembles the boot sector, and combines everything into a bootable image for QEMU.

14. Q: What are the utility functions provided in libc?
A: libc provides memory functions (`memory_copy`, `memory_set`), string functions (`strlen`, `strcmp`, `append`, `backspace`), and integer-to-string conversions.

15. Q: How are hardware ports accessed from C?
A: Hardware ports are accessed using inline assembly functions (`port_byte_in`, `port_byte_out`, etc.) in `ports.c` and `ports.h`.

16. Q: How are exceptions and IRQs differentiated and handled?
A: Exceptions (ISRs) and IRQs have separate handler stubs and are registered at different IDT entries. The OS remaps IRQs to avoid overlap with exceptions.

17. Q: What is the role of each assembly file in the boot process?
A: `bootsect.asm` loads the kernel, `gdt.asm` sets up the GDT, `switch_pm.asm` switches to protected mode, and `kernel_entry.asm` jumps to the kernel's main function.

18. Q: How does the OS handle backspace and enter keys?
A: The keyboard driver detects backspace and enter scancodes, updates the input buffer, and calls appropriate screen functions to update the display.

19. Q: How does the kernel halt the CPU?
A: The kernel executes the `hlt` instruction in response to the END command, stopping the CPU.

20. Q: How does the OS print hexadecimal numbers?
A: The OS uses `print_hex.asm` in real mode and `hex_to_ascii` in protected mode to convert numbers to hexadecimal strings for display.

21. Q: What is the structure of the kernelâ€™s main loop?
A: The kernel initializes interrupts and drivers, prints a welcome message, and waits for user input in a command loop.

22. Q: How does the OS handle paging and physical addresses?
A: The OS's `kmalloc` can return both virtual and physical addresses, supporting page-aligned allocations if requested.

23. Q: What is the purpose of the `UNUSED` macro?
A: The `UNUSED` macro suppresses compiler warnings for unused function parameters.

24. Q: How does the OS clear the screen?
A: The `clear_screen` function fills the VGA text buffer with spaces and resets the cursor position.

25. Q: How does the OS handle cursor movement?
A: The OS reads and writes to VGA control ports to get and set the cursor position on the screen.

26. Q: How does the OS handle string operations?
A: The OS implements its own versions of `strlen`, `strcmp`, `append`, `backspace`, and string reversal in `string.c`.

27. Q: What is the role of the `registers_t` struct?
A: `registers_t` aggregates CPU register values pushed during an interrupt, allowing handlers to access CPU state.

28. Q: How does the OS handle timer interrupts?
A: The timer driver registers a callback for IRQ0, which increments a tick counter on each timer interrupt.

29. Q: How does the OS handle keyboard interrupts?
A: The keyboard driver registers a callback for IRQ1, which processes scancodes and updates the input buffer.

30. Q: How does the OS print error messages for exceptions?
A: The OS maintains an array of exception messages and prints the appropriate message when an exception occurs.

31. Q: How does the OS handle stack faults and page faults?
A: The OS prints error messages and diagnostic information when these exceptions occur, using the exception handler.

32. Q: How does the OS handle division by zero?
A: The division by zero exception is handled by the ISR0 handler, which prints an error message.

33. Q: How does the OS handle unknown interrupts?
A: Unknown interrupts print a generic error message using the exception handler.

34. Q: How does the OS handle physical and virtual memory addresses?
A: The OS can return both physical and virtual addresses from `kmalloc` for use in paging and memory management.

35. Q: How does the OS handle the end of user input?
A: When the user presses enter, the input buffer is passed to the kernel for processing.

36. Q: How does the OS handle the PAGE command?
A: The kernel allocates a page of memory, prints its address, and the corresponding physical address.

37. Q: How does the OS handle the END command?
A: The kernel prints a goodbye message and halts the CPU.

38. Q: How does the OS handle the VGA text buffer?
A: The OS writes characters and attributes directly to the VGA memory at 0xb8000 for text display.

39. Q: How does the OS handle scrolling the screen?
A: When the cursor reaches the bottom of the screen, the OS scrolls the contents up and clears the last line.

40. Q: How does the OS handle the BIOS interrupts?
A: The bootloader uses BIOS interrupts (e.g., int 0x10 for printing, int 0x13 for disk access) in real mode.

41. Q: How does the OS handle disk loading?
A: The bootloader reads sectors from disk into memory using BIOS int 0x13, as implemented in `disk.asm`.

42. Q: How does the OS handle segment selectors?
A: Segment selectors are defined in the GDT and used to set up code and data segments in protected mode.

43. Q: How does the OS handle the kernel entry point?
A: The bootloader jumps to the kernel's entry point (`kernel_main`) after switching to protected mode.

44. Q: How does the OS handle the stack in protected mode?
A: The stack pointer is set to a known location in memory after switching to protected mode.

45. Q: How does the OS handle the transition to the kernel?
A: The bootloader calls the kernel's main function after setting up the environment in protected mode.

46. Q: How does the OS handle the Makefile clean command?
A: The clean command removes all generated binaries, object files, and build artifacts.

47. Q: How does the OS handle debugging with QEMU and GDB?
A: The Makefile provides a debug target that runs QEMU with GDB support and loads the kernel symbols for debugging.

48. Q: How does the OS handle the linking of the kernel?
A: The kernel is linked at address 0x1000 using a linker script and the `i686-elf-ld` tool.

49. Q: How does the OS handle the boot drive?
A: The bootloader stores the boot drive number in memory for later use during disk operations.

50. Q: How does the OS handle error codes in interrupts?
A: The interrupt stubs push error codes onto the stack for exceptions that require them, ensuring consistent stack layout for all handlers.
